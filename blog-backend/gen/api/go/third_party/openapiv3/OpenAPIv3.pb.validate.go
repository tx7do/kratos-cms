// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: third_party/openapiv3/OpenAPIv3.proto

package openapi_v3

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on AdditionalPropertiesItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AdditionalPropertiesItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdditionalPropertiesItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AdditionalPropertiesItemMultiError, or nil if none found.
func (m *AdditionalPropertiesItem) ValidateAll() error {
	return m.validate(true)
}

func (m *AdditionalPropertiesItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Oneof.(type) {
	case *AdditionalPropertiesItem_SchemaOrReference:
		if v == nil {
			err := AdditionalPropertiesItemValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSchemaOrReference()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AdditionalPropertiesItemValidationError{
						field:  "SchemaOrReference",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AdditionalPropertiesItemValidationError{
						field:  "SchemaOrReference",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSchemaOrReference()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AdditionalPropertiesItemValidationError{
					field:  "SchemaOrReference",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AdditionalPropertiesItem_Boolean:
		if v == nil {
			err := AdditionalPropertiesItemValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Boolean
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AdditionalPropertiesItemMultiError(errors)
	}

	return nil
}

// AdditionalPropertiesItemMultiError is an error wrapping multiple validation
// errors returned by AdditionalPropertiesItem.ValidateAll() if the designated
// constraints aren't met.
type AdditionalPropertiesItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdditionalPropertiesItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdditionalPropertiesItemMultiError) AllErrors() []error { return m }

// AdditionalPropertiesItemValidationError is the validation error returned by
// AdditionalPropertiesItem.Validate if the designated constraints aren't met.
type AdditionalPropertiesItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdditionalPropertiesItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdditionalPropertiesItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdditionalPropertiesItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdditionalPropertiesItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdditionalPropertiesItemValidationError) ErrorName() string {
	return "AdditionalPropertiesItemValidationError"
}

// Error satisfies the builtin error interface
func (e AdditionalPropertiesItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdditionalPropertiesItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdditionalPropertiesItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdditionalPropertiesItemValidationError{}

// Validate checks the field values on Any with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Any) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Any with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AnyMultiError, or nil if none found.
func (m *Any) ValidateAll() error {
	return m.validate(true)
}

func (m *Any) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AnyValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AnyValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AnyValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Yaml

	if len(errors) > 0 {
		return AnyMultiError(errors)
	}

	return nil
}

// AnyMultiError is an error wrapping multiple validation errors returned by
// Any.ValidateAll() if the designated constraints aren't met.
type AnyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnyMultiError) AllErrors() []error { return m }

// AnyValidationError is the validation error returned by Any.Validate if the
// designated constraints aren't met.
type AnyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnyValidationError) ErrorName() string { return "AnyValidationError" }

// Error satisfies the builtin error interface
func (e AnyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAny.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnyValidationError{}

// Validate checks the field values on AnyOrExpression with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AnyOrExpression) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AnyOrExpression with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AnyOrExpressionMultiError, or nil if none found.
func (m *AnyOrExpression) ValidateAll() error {
	return m.validate(true)
}

func (m *AnyOrExpression) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Oneof.(type) {
	case *AnyOrExpression_Any:
		if v == nil {
			err := AnyOrExpressionValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAny()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AnyOrExpressionValidationError{
						field:  "Any",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AnyOrExpressionValidationError{
						field:  "Any",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAny()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AnyOrExpressionValidationError{
					field:  "Any",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AnyOrExpression_Expression:
		if v == nil {
			err := AnyOrExpressionValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetExpression()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AnyOrExpressionValidationError{
						field:  "Expression",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AnyOrExpressionValidationError{
						field:  "Expression",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExpression()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AnyOrExpressionValidationError{
					field:  "Expression",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AnyOrExpressionMultiError(errors)
	}

	return nil
}

// AnyOrExpressionMultiError is an error wrapping multiple validation errors
// returned by AnyOrExpression.ValidateAll() if the designated constraints
// aren't met.
type AnyOrExpressionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnyOrExpressionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnyOrExpressionMultiError) AllErrors() []error { return m }

// AnyOrExpressionValidationError is the validation error returned by
// AnyOrExpression.Validate if the designated constraints aren't met.
type AnyOrExpressionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnyOrExpressionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnyOrExpressionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnyOrExpressionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnyOrExpressionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnyOrExpressionValidationError) ErrorName() string { return "AnyOrExpressionValidationError" }

// Error satisfies the builtin error interface
func (e AnyOrExpressionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnyOrExpression.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnyOrExpressionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnyOrExpressionValidationError{}

// Validate checks the field values on Callback with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Callback) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Callback with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CallbackMultiError, or nil
// if none found.
func (m *Callback) ValidateAll() error {
	return m.validate(true)
}

func (m *Callback) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPath() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CallbackValidationError{
						field:  fmt.Sprintf("Path[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CallbackValidationError{
						field:  fmt.Sprintf("Path[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CallbackValidationError{
					field:  fmt.Sprintf("Path[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CallbackValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CallbackValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CallbackValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CallbackMultiError(errors)
	}

	return nil
}

// CallbackMultiError is an error wrapping multiple validation errors returned
// by Callback.ValidateAll() if the designated constraints aren't met.
type CallbackMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CallbackMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CallbackMultiError) AllErrors() []error { return m }

// CallbackValidationError is the validation error returned by
// Callback.Validate if the designated constraints aren't met.
type CallbackValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CallbackValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CallbackValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CallbackValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CallbackValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CallbackValidationError) ErrorName() string { return "CallbackValidationError" }

// Error satisfies the builtin error interface
func (e CallbackValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCallback.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CallbackValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CallbackValidationError{}

// Validate checks the field values on CallbackOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CallbackOrReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CallbackOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CallbackOrReferenceMultiError, or nil if none found.
func (m *CallbackOrReference) ValidateAll() error {
	return m.validate(true)
}

func (m *CallbackOrReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Oneof.(type) {
	case *CallbackOrReference_Callback:
		if v == nil {
			err := CallbackOrReferenceValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCallback()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CallbackOrReferenceValidationError{
						field:  "Callback",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CallbackOrReferenceValidationError{
						field:  "Callback",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCallback()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CallbackOrReferenceValidationError{
					field:  "Callback",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CallbackOrReference_Reference:
		if v == nil {
			err := CallbackOrReferenceValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReference()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CallbackOrReferenceValidationError{
						field:  "Reference",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CallbackOrReferenceValidationError{
						field:  "Reference",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReference()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CallbackOrReferenceValidationError{
					field:  "Reference",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return CallbackOrReferenceMultiError(errors)
	}

	return nil
}

// CallbackOrReferenceMultiError is an error wrapping multiple validation
// errors returned by CallbackOrReference.ValidateAll() if the designated
// constraints aren't met.
type CallbackOrReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CallbackOrReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CallbackOrReferenceMultiError) AllErrors() []error { return m }

// CallbackOrReferenceValidationError is the validation error returned by
// CallbackOrReference.Validate if the designated constraints aren't met.
type CallbackOrReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CallbackOrReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CallbackOrReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CallbackOrReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CallbackOrReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CallbackOrReferenceValidationError) ErrorName() string {
	return "CallbackOrReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e CallbackOrReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCallbackOrReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CallbackOrReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CallbackOrReferenceValidationError{}

// Validate checks the field values on CallbacksOrReferences with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CallbacksOrReferences) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CallbacksOrReferences with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CallbacksOrReferencesMultiError, or nil if none found.
func (m *CallbacksOrReferences) ValidateAll() error {
	return m.validate(true)
}

func (m *CallbacksOrReferences) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAdditionalProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CallbacksOrReferencesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CallbacksOrReferencesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CallbacksOrReferencesValidationError{
					field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CallbacksOrReferencesMultiError(errors)
	}

	return nil
}

// CallbacksOrReferencesMultiError is an error wrapping multiple validation
// errors returned by CallbacksOrReferences.ValidateAll() if the designated
// constraints aren't met.
type CallbacksOrReferencesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CallbacksOrReferencesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CallbacksOrReferencesMultiError) AllErrors() []error { return m }

// CallbacksOrReferencesValidationError is the validation error returned by
// CallbacksOrReferences.Validate if the designated constraints aren't met.
type CallbacksOrReferencesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CallbacksOrReferencesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CallbacksOrReferencesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CallbacksOrReferencesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CallbacksOrReferencesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CallbacksOrReferencesValidationError) ErrorName() string {
	return "CallbacksOrReferencesValidationError"
}

// Error satisfies the builtin error interface
func (e CallbacksOrReferencesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCallbacksOrReferences.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CallbacksOrReferencesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CallbacksOrReferencesValidationError{}

// Validate checks the field values on Components with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Components) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Components with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ComponentsMultiError, or
// nil if none found.
func (m *Components) ValidateAll() error {
	return m.validate(true)
}

func (m *Components) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSchemas()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentsValidationError{
					field:  "Schemas",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentsValidationError{
					field:  "Schemas",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSchemas()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentsValidationError{
				field:  "Schemas",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResponses()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentsValidationError{
					field:  "Responses",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentsValidationError{
					field:  "Responses",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponses()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentsValidationError{
				field:  "Responses",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentsValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentsValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentsValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExamples()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentsValidationError{
					field:  "Examples",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentsValidationError{
					field:  "Examples",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExamples()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentsValidationError{
				field:  "Examples",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRequestBodies()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentsValidationError{
					field:  "RequestBodies",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentsValidationError{
					field:  "RequestBodies",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequestBodies()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentsValidationError{
				field:  "RequestBodies",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetHeaders()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentsValidationError{
					field:  "Headers",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentsValidationError{
					field:  "Headers",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHeaders()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentsValidationError{
				field:  "Headers",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSecuritySchemes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentsValidationError{
					field:  "SecuritySchemes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentsValidationError{
					field:  "SecuritySchemes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecuritySchemes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentsValidationError{
				field:  "SecuritySchemes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLinks()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentsValidationError{
					field:  "Links",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentsValidationError{
					field:  "Links",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLinks()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentsValidationError{
				field:  "Links",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCallbacks()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentsValidationError{
					field:  "Callbacks",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentsValidationError{
					field:  "Callbacks",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCallbacks()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentsValidationError{
				field:  "Callbacks",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ComponentsValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ComponentsValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ComponentsValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ComponentsMultiError(errors)
	}

	return nil
}

// ComponentsMultiError is an error wrapping multiple validation errors
// returned by Components.ValidateAll() if the designated constraints aren't met.
type ComponentsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComponentsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComponentsMultiError) AllErrors() []error { return m }

// ComponentsValidationError is the validation error returned by
// Components.Validate if the designated constraints aren't met.
type ComponentsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComponentsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComponentsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComponentsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComponentsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComponentsValidationError) ErrorName() string { return "ComponentsValidationError" }

// Error satisfies the builtin error interface
func (e ComponentsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sComponents.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComponentsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComponentsValidationError{}

// Validate checks the field values on Contact with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Contact) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Contact with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ContactMultiError, or nil if none found.
func (m *Contact) ValidateAll() error {
	return m.validate(true)
}

func (m *Contact) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Url

	// no validation rules for Email

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ContactValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ContactValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ContactValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ContactMultiError(errors)
	}

	return nil
}

// ContactMultiError is an error wrapping multiple validation errors returned
// by Contact.ValidateAll() if the designated constraints aren't met.
type ContactMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContactMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContactMultiError) AllErrors() []error { return m }

// ContactValidationError is the validation error returned by Contact.Validate
// if the designated constraints aren't met.
type ContactValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContactValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContactValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContactValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContactValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContactValidationError) ErrorName() string { return "ContactValidationError" }

// Error satisfies the builtin error interface
func (e ContactValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContact.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContactValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContactValidationError{}

// Validate checks the field values on DefaultType with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DefaultType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DefaultType with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DefaultTypeMultiError, or
// nil if none found.
func (m *DefaultType) ValidateAll() error {
	return m.validate(true)
}

func (m *DefaultType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Oneof.(type) {
	case *DefaultType_Number:
		if v == nil {
			err := DefaultTypeValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Number
	case *DefaultType_Boolean:
		if v == nil {
			err := DefaultTypeValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Boolean
	case *DefaultType_String_:
		if v == nil {
			err := DefaultTypeValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for String_
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return DefaultTypeMultiError(errors)
	}

	return nil
}

// DefaultTypeMultiError is an error wrapping multiple validation errors
// returned by DefaultType.ValidateAll() if the designated constraints aren't met.
type DefaultTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DefaultTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DefaultTypeMultiError) AllErrors() []error { return m }

// DefaultTypeValidationError is the validation error returned by
// DefaultType.Validate if the designated constraints aren't met.
type DefaultTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DefaultTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DefaultTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DefaultTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DefaultTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DefaultTypeValidationError) ErrorName() string { return "DefaultTypeValidationError" }

// Error satisfies the builtin error interface
func (e DefaultTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDefaultType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DefaultTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DefaultTypeValidationError{}

// Validate checks the field values on Discriminator with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Discriminator) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Discriminator with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DiscriminatorMultiError, or
// nil if none found.
func (m *Discriminator) ValidateAll() error {
	return m.validate(true)
}

func (m *Discriminator) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PropertyName

	if all {
		switch v := interface{}(m.GetMapping()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DiscriminatorValidationError{
					field:  "Mapping",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DiscriminatorValidationError{
					field:  "Mapping",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMapping()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DiscriminatorValidationError{
				field:  "Mapping",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DiscriminatorValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DiscriminatorValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DiscriminatorValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DiscriminatorMultiError(errors)
	}

	return nil
}

// DiscriminatorMultiError is an error wrapping multiple validation errors
// returned by Discriminator.ValidateAll() if the designated constraints
// aren't met.
type DiscriminatorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DiscriminatorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DiscriminatorMultiError) AllErrors() []error { return m }

// DiscriminatorValidationError is the validation error returned by
// Discriminator.Validate if the designated constraints aren't met.
type DiscriminatorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DiscriminatorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DiscriminatorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DiscriminatorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DiscriminatorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DiscriminatorValidationError) ErrorName() string { return "DiscriminatorValidationError" }

// Error satisfies the builtin error interface
func (e DiscriminatorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDiscriminator.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DiscriminatorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DiscriminatorValidationError{}

// Validate checks the field values on Document with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Document) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Document with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DocumentMultiError, or nil
// if none found.
func (m *Document) ValidateAll() error {
	return m.validate(true)
}

func (m *Document) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Openapi

	if all {
		switch v := interface{}(m.GetInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentValidationError{
				field:  "Info",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetServers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentValidationError{
						field:  fmt.Sprintf("Servers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentValidationError{
						field:  fmt.Sprintf("Servers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentValidationError{
					field:  fmt.Sprintf("Servers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPaths()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentValidationError{
					field:  "Paths",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentValidationError{
					field:  "Paths",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaths()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentValidationError{
				field:  "Paths",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetComponents()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentValidationError{
					field:  "Components",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentValidationError{
					field:  "Components",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetComponents()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentValidationError{
				field:  "Components",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSecurity() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentValidationError{
						field:  fmt.Sprintf("Security[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentValidationError{
						field:  fmt.Sprintf("Security[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentValidationError{
					field:  fmt.Sprintf("Security[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetExternalDocs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentValidationError{
					field:  "ExternalDocs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentValidationError{
					field:  "ExternalDocs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExternalDocs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentValidationError{
				field:  "ExternalDocs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DocumentMultiError(errors)
	}

	return nil
}

// DocumentMultiError is an error wrapping multiple validation errors returned
// by Document.ValidateAll() if the designated constraints aren't met.
type DocumentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentMultiError) AllErrors() []error { return m }

// DocumentValidationError is the validation error returned by
// Document.Validate if the designated constraints aren't met.
type DocumentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentValidationError) ErrorName() string { return "DocumentValidationError" }

// Error satisfies the builtin error interface
func (e DocumentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocument.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentValidationError{}

// Validate checks the field values on Encoding with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Encoding) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Encoding with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EncodingMultiError, or nil
// if none found.
func (m *Encoding) ValidateAll() error {
	return m.validate(true)
}

func (m *Encoding) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ContentType

	if all {
		switch v := interface{}(m.GetHeaders()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EncodingValidationError{
					field:  "Headers",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EncodingValidationError{
					field:  "Headers",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHeaders()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EncodingValidationError{
				field:  "Headers",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Style

	// no validation rules for Explode

	// no validation rules for AllowReserved

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EncodingValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EncodingValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EncodingValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EncodingMultiError(errors)
	}

	return nil
}

// EncodingMultiError is an error wrapping multiple validation errors returned
// by Encoding.ValidateAll() if the designated constraints aren't met.
type EncodingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EncodingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EncodingMultiError) AllErrors() []error { return m }

// EncodingValidationError is the validation error returned by
// Encoding.Validate if the designated constraints aren't met.
type EncodingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EncodingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EncodingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EncodingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EncodingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EncodingValidationError) ErrorName() string { return "EncodingValidationError" }

// Error satisfies the builtin error interface
func (e EncodingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEncoding.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EncodingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EncodingValidationError{}

// Validate checks the field values on Encodings with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Encodings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Encodings with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EncodingsMultiError, or nil
// if none found.
func (m *Encodings) ValidateAll() error {
	return m.validate(true)
}

func (m *Encodings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAdditionalProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EncodingsValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EncodingsValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EncodingsValidationError{
					field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EncodingsMultiError(errors)
	}

	return nil
}

// EncodingsMultiError is an error wrapping multiple validation errors returned
// by Encodings.ValidateAll() if the designated constraints aren't met.
type EncodingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EncodingsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EncodingsMultiError) AllErrors() []error { return m }

// EncodingsValidationError is the validation error returned by
// Encodings.Validate if the designated constraints aren't met.
type EncodingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EncodingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EncodingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EncodingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EncodingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EncodingsValidationError) ErrorName() string { return "EncodingsValidationError" }

// Error satisfies the builtin error interface
func (e EncodingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEncodings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EncodingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EncodingsValidationError{}

// Validate checks the field values on Example with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Example) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Example with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ExampleMultiError, or nil if none found.
func (m *Example) ValidateAll() error {
	return m.validate(true)
}

func (m *Example) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Summary

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExampleValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExampleValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExampleValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ExternalValue

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExampleValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExampleValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExampleValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExampleMultiError(errors)
	}

	return nil
}

// ExampleMultiError is an error wrapping multiple validation errors returned
// by Example.ValidateAll() if the designated constraints aren't met.
type ExampleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExampleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExampleMultiError) AllErrors() []error { return m }

// ExampleValidationError is the validation error returned by Example.Validate
// if the designated constraints aren't met.
type ExampleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExampleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExampleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExampleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExampleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExampleValidationError) ErrorName() string { return "ExampleValidationError" }

// Error satisfies the builtin error interface
func (e ExampleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExample.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExampleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExampleValidationError{}

// Validate checks the field values on ExampleOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExampleOrReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExampleOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExampleOrReferenceMultiError, or nil if none found.
func (m *ExampleOrReference) ValidateAll() error {
	return m.validate(true)
}

func (m *ExampleOrReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Oneof.(type) {
	case *ExampleOrReference_Example:
		if v == nil {
			err := ExampleOrReferenceValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetExample()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExampleOrReferenceValidationError{
						field:  "Example",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExampleOrReferenceValidationError{
						field:  "Example",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExample()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExampleOrReferenceValidationError{
					field:  "Example",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExampleOrReference_Reference:
		if v == nil {
			err := ExampleOrReferenceValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReference()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExampleOrReferenceValidationError{
						field:  "Reference",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExampleOrReferenceValidationError{
						field:  "Reference",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReference()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExampleOrReferenceValidationError{
					field:  "Reference",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ExampleOrReferenceMultiError(errors)
	}

	return nil
}

// ExampleOrReferenceMultiError is an error wrapping multiple validation errors
// returned by ExampleOrReference.ValidateAll() if the designated constraints
// aren't met.
type ExampleOrReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExampleOrReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExampleOrReferenceMultiError) AllErrors() []error { return m }

// ExampleOrReferenceValidationError is the validation error returned by
// ExampleOrReference.Validate if the designated constraints aren't met.
type ExampleOrReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExampleOrReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExampleOrReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExampleOrReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExampleOrReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExampleOrReferenceValidationError) ErrorName() string {
	return "ExampleOrReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e ExampleOrReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExampleOrReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExampleOrReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExampleOrReferenceValidationError{}

// Validate checks the field values on ExamplesOrReferences with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExamplesOrReferences) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExamplesOrReferences with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExamplesOrReferencesMultiError, or nil if none found.
func (m *ExamplesOrReferences) ValidateAll() error {
	return m.validate(true)
}

func (m *ExamplesOrReferences) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAdditionalProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExamplesOrReferencesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExamplesOrReferencesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExamplesOrReferencesValidationError{
					field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExamplesOrReferencesMultiError(errors)
	}

	return nil
}

// ExamplesOrReferencesMultiError is an error wrapping multiple validation
// errors returned by ExamplesOrReferences.ValidateAll() if the designated
// constraints aren't met.
type ExamplesOrReferencesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExamplesOrReferencesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExamplesOrReferencesMultiError) AllErrors() []error { return m }

// ExamplesOrReferencesValidationError is the validation error returned by
// ExamplesOrReferences.Validate if the designated constraints aren't met.
type ExamplesOrReferencesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExamplesOrReferencesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExamplesOrReferencesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExamplesOrReferencesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExamplesOrReferencesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExamplesOrReferencesValidationError) ErrorName() string {
	return "ExamplesOrReferencesValidationError"
}

// Error satisfies the builtin error interface
func (e ExamplesOrReferencesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExamplesOrReferences.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExamplesOrReferencesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExamplesOrReferencesValidationError{}

// Validate checks the field values on Expression with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Expression) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Expression with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExpressionMultiError, or
// nil if none found.
func (m *Expression) ValidateAll() error {
	return m.validate(true)
}

func (m *Expression) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAdditionalProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpressionValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpressionValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpressionValidationError{
					field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExpressionMultiError(errors)
	}

	return nil
}

// ExpressionMultiError is an error wrapping multiple validation errors
// returned by Expression.ValidateAll() if the designated constraints aren't met.
type ExpressionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpressionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpressionMultiError) AllErrors() []error { return m }

// ExpressionValidationError is the validation error returned by
// Expression.Validate if the designated constraints aren't met.
type ExpressionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpressionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpressionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpressionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpressionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpressionValidationError) ErrorName() string { return "ExpressionValidationError" }

// Error satisfies the builtin error interface
func (e ExpressionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpression.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpressionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpressionValidationError{}

// Validate checks the field values on ExternalDocs with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExternalDocs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExternalDocs with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExternalDocsMultiError, or
// nil if none found.
func (m *ExternalDocs) ValidateAll() error {
	return m.validate(true)
}

func (m *ExternalDocs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Description

	// no validation rules for Url

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExternalDocsValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExternalDocsValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExternalDocsValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExternalDocsMultiError(errors)
	}

	return nil
}

// ExternalDocsMultiError is an error wrapping multiple validation errors
// returned by ExternalDocs.ValidateAll() if the designated constraints aren't met.
type ExternalDocsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExternalDocsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExternalDocsMultiError) AllErrors() []error { return m }

// ExternalDocsValidationError is the validation error returned by
// ExternalDocs.Validate if the designated constraints aren't met.
type ExternalDocsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExternalDocsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExternalDocsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExternalDocsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExternalDocsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExternalDocsValidationError) ErrorName() string { return "ExternalDocsValidationError" }

// Error satisfies the builtin error interface
func (e ExternalDocsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExternalDocs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExternalDocsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExternalDocsValidationError{}

// Validate checks the field values on Header with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Header) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Header with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in HeaderMultiError, or nil if none found.
func (m *Header) ValidateAll() error {
	return m.validate(true)
}

func (m *Header) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Description

	// no validation rules for Required

	// no validation rules for Deprecated

	// no validation rules for AllowEmptyValue

	// no validation rules for Style

	// no validation rules for Explode

	// no validation rules for AllowReserved

	if all {
		switch v := interface{}(m.GetSchema()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HeaderValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HeaderValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSchema()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HeaderValidationError{
				field:  "Schema",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExample()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HeaderValidationError{
					field:  "Example",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HeaderValidationError{
					field:  "Example",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExample()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HeaderValidationError{
				field:  "Example",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExamples()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HeaderValidationError{
					field:  "Examples",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HeaderValidationError{
					field:  "Examples",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExamples()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HeaderValidationError{
				field:  "Examples",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetContent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HeaderValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HeaderValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HeaderValidationError{
				field:  "Content",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HeaderValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HeaderValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HeaderValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HeaderMultiError(errors)
	}

	return nil
}

// HeaderMultiError is an error wrapping multiple validation errors returned by
// Header.ValidateAll() if the designated constraints aren't met.
type HeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HeaderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HeaderMultiError) AllErrors() []error { return m }

// HeaderValidationError is the validation error returned by Header.Validate if
// the designated constraints aren't met.
type HeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HeaderValidationError) ErrorName() string { return "HeaderValidationError" }

// Error satisfies the builtin error interface
func (e HeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHeader.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HeaderValidationError{}

// Validate checks the field values on HeaderOrReference with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HeaderOrReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HeaderOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HeaderOrReferenceMultiError, or nil if none found.
func (m *HeaderOrReference) ValidateAll() error {
	return m.validate(true)
}

func (m *HeaderOrReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Oneof.(type) {
	case *HeaderOrReference_Header:
		if v == nil {
			err := HeaderOrReferenceValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHeader()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HeaderOrReferenceValidationError{
						field:  "Header",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HeaderOrReferenceValidationError{
						field:  "Header",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHeader()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HeaderOrReferenceValidationError{
					field:  "Header",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *HeaderOrReference_Reference:
		if v == nil {
			err := HeaderOrReferenceValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReference()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HeaderOrReferenceValidationError{
						field:  "Reference",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HeaderOrReferenceValidationError{
						field:  "Reference",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReference()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HeaderOrReferenceValidationError{
					field:  "Reference",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return HeaderOrReferenceMultiError(errors)
	}

	return nil
}

// HeaderOrReferenceMultiError is an error wrapping multiple validation errors
// returned by HeaderOrReference.ValidateAll() if the designated constraints
// aren't met.
type HeaderOrReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HeaderOrReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HeaderOrReferenceMultiError) AllErrors() []error { return m }

// HeaderOrReferenceValidationError is the validation error returned by
// HeaderOrReference.Validate if the designated constraints aren't met.
type HeaderOrReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HeaderOrReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HeaderOrReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HeaderOrReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HeaderOrReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HeaderOrReferenceValidationError) ErrorName() string {
	return "HeaderOrReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e HeaderOrReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHeaderOrReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HeaderOrReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HeaderOrReferenceValidationError{}

// Validate checks the field values on HeadersOrReferences with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HeadersOrReferences) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HeadersOrReferences with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HeadersOrReferencesMultiError, or nil if none found.
func (m *HeadersOrReferences) ValidateAll() error {
	return m.validate(true)
}

func (m *HeadersOrReferences) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAdditionalProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HeadersOrReferencesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HeadersOrReferencesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HeadersOrReferencesValidationError{
					field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HeadersOrReferencesMultiError(errors)
	}

	return nil
}

// HeadersOrReferencesMultiError is an error wrapping multiple validation
// errors returned by HeadersOrReferences.ValidateAll() if the designated
// constraints aren't met.
type HeadersOrReferencesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HeadersOrReferencesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HeadersOrReferencesMultiError) AllErrors() []error { return m }

// HeadersOrReferencesValidationError is the validation error returned by
// HeadersOrReferences.Validate if the designated constraints aren't met.
type HeadersOrReferencesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HeadersOrReferencesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HeadersOrReferencesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HeadersOrReferencesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HeadersOrReferencesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HeadersOrReferencesValidationError) ErrorName() string {
	return "HeadersOrReferencesValidationError"
}

// Error satisfies the builtin error interface
func (e HeadersOrReferencesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHeadersOrReferences.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HeadersOrReferencesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HeadersOrReferencesValidationError{}

// Validate checks the field values on Info with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Info) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Info with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in InfoMultiError, or nil if none found.
func (m *Info) ValidateAll() error {
	return m.validate(true)
}

func (m *Info) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for Description

	// no validation rules for TermsOfService

	if all {
		switch v := interface{}(m.GetContact()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InfoValidationError{
					field:  "Contact",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InfoValidationError{
					field:  "Contact",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContact()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InfoValidationError{
				field:  "Contact",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLicense()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InfoValidationError{
					field:  "License",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InfoValidationError{
					field:  "License",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLicense()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InfoValidationError{
				field:  "License",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Version

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InfoValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InfoValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InfoValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Summary

	if len(errors) > 0 {
		return InfoMultiError(errors)
	}

	return nil
}

// InfoMultiError is an error wrapping multiple validation errors returned by
// Info.ValidateAll() if the designated constraints aren't met.
type InfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InfoMultiError) AllErrors() []error { return m }

// InfoValidationError is the validation error returned by Info.Validate if the
// designated constraints aren't met.
type InfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InfoValidationError) ErrorName() string { return "InfoValidationError" }

// Error satisfies the builtin error interface
func (e InfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InfoValidationError{}

// Validate checks the field values on ItemsItem with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ItemsItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ItemsItem with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ItemsItemMultiError, or nil
// if none found.
func (m *ItemsItem) ValidateAll() error {
	return m.validate(true)
}

func (m *ItemsItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSchemaOrReference() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ItemsItemValidationError{
						field:  fmt.Sprintf("SchemaOrReference[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ItemsItemValidationError{
						field:  fmt.Sprintf("SchemaOrReference[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ItemsItemValidationError{
					field:  fmt.Sprintf("SchemaOrReference[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ItemsItemMultiError(errors)
	}

	return nil
}

// ItemsItemMultiError is an error wrapping multiple validation errors returned
// by ItemsItem.ValidateAll() if the designated constraints aren't met.
type ItemsItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ItemsItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ItemsItemMultiError) AllErrors() []error { return m }

// ItemsItemValidationError is the validation error returned by
// ItemsItem.Validate if the designated constraints aren't met.
type ItemsItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ItemsItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ItemsItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ItemsItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ItemsItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ItemsItemValidationError) ErrorName() string { return "ItemsItemValidationError" }

// Error satisfies the builtin error interface
func (e ItemsItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sItemsItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ItemsItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ItemsItemValidationError{}

// Validate checks the field values on License with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *License) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on License with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LicenseMultiError, or nil if none found.
func (m *License) ValidateAll() error {
	return m.validate(true)
}

func (m *License) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Url

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LicenseValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LicenseValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LicenseValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LicenseMultiError(errors)
	}

	return nil
}

// LicenseMultiError is an error wrapping multiple validation errors returned
// by License.ValidateAll() if the designated constraints aren't met.
type LicenseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LicenseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LicenseMultiError) AllErrors() []error { return m }

// LicenseValidationError is the validation error returned by License.Validate
// if the designated constraints aren't met.
type LicenseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LicenseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LicenseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LicenseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LicenseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LicenseValidationError) ErrorName() string { return "LicenseValidationError" }

// Error satisfies the builtin error interface
func (e LicenseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLicense.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LicenseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LicenseValidationError{}

// Validate checks the field values on Link with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Link) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Link with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LinkMultiError, or nil if none found.
func (m *Link) ValidateAll() error {
	return m.validate(true)
}

func (m *Link) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OperationRef

	// no validation rules for OperationId

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LinkValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LinkValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LinkValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRequestBody()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LinkValidationError{
					field:  "RequestBody",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LinkValidationError{
					field:  "RequestBody",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequestBody()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LinkValidationError{
				field:  "RequestBody",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetServer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LinkValidationError{
					field:  "Server",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LinkValidationError{
					field:  "Server",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetServer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LinkValidationError{
				field:  "Server",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LinkMultiError(errors)
	}

	return nil
}

// LinkMultiError is an error wrapping multiple validation errors returned by
// Link.ValidateAll() if the designated constraints aren't met.
type LinkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LinkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LinkMultiError) AllErrors() []error { return m }

// LinkValidationError is the validation error returned by Link.Validate if the
// designated constraints aren't met.
type LinkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LinkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LinkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LinkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LinkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LinkValidationError) ErrorName() string { return "LinkValidationError" }

// Error satisfies the builtin error interface
func (e LinkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLink.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LinkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LinkValidationError{}

// Validate checks the field values on LinkOrReference with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LinkOrReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LinkOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LinkOrReferenceMultiError, or nil if none found.
func (m *LinkOrReference) ValidateAll() error {
	return m.validate(true)
}

func (m *LinkOrReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Oneof.(type) {
	case *LinkOrReference_Link:
		if v == nil {
			err := LinkOrReferenceValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLink()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkOrReferenceValidationError{
						field:  "Link",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkOrReferenceValidationError{
						field:  "Link",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLink()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkOrReferenceValidationError{
					field:  "Link",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *LinkOrReference_Reference:
		if v == nil {
			err := LinkOrReferenceValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReference()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkOrReferenceValidationError{
						field:  "Reference",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkOrReferenceValidationError{
						field:  "Reference",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReference()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkOrReferenceValidationError{
					field:  "Reference",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return LinkOrReferenceMultiError(errors)
	}

	return nil
}

// LinkOrReferenceMultiError is an error wrapping multiple validation errors
// returned by LinkOrReference.ValidateAll() if the designated constraints
// aren't met.
type LinkOrReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LinkOrReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LinkOrReferenceMultiError) AllErrors() []error { return m }

// LinkOrReferenceValidationError is the validation error returned by
// LinkOrReference.Validate if the designated constraints aren't met.
type LinkOrReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LinkOrReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LinkOrReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LinkOrReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LinkOrReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LinkOrReferenceValidationError) ErrorName() string { return "LinkOrReferenceValidationError" }

// Error satisfies the builtin error interface
func (e LinkOrReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLinkOrReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LinkOrReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LinkOrReferenceValidationError{}

// Validate checks the field values on LinksOrReferences with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LinksOrReferences) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LinksOrReferences with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LinksOrReferencesMultiError, or nil if none found.
func (m *LinksOrReferences) ValidateAll() error {
	return m.validate(true)
}

func (m *LinksOrReferences) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAdditionalProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinksOrReferencesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinksOrReferencesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinksOrReferencesValidationError{
					field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LinksOrReferencesMultiError(errors)
	}

	return nil
}

// LinksOrReferencesMultiError is an error wrapping multiple validation errors
// returned by LinksOrReferences.ValidateAll() if the designated constraints
// aren't met.
type LinksOrReferencesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LinksOrReferencesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LinksOrReferencesMultiError) AllErrors() []error { return m }

// LinksOrReferencesValidationError is the validation error returned by
// LinksOrReferences.Validate if the designated constraints aren't met.
type LinksOrReferencesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LinksOrReferencesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LinksOrReferencesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LinksOrReferencesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LinksOrReferencesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LinksOrReferencesValidationError) ErrorName() string {
	return "LinksOrReferencesValidationError"
}

// Error satisfies the builtin error interface
func (e LinksOrReferencesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLinksOrReferences.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LinksOrReferencesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LinksOrReferencesValidationError{}

// Validate checks the field values on MediaType with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MediaType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MediaType with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MediaTypeMultiError, or nil
// if none found.
func (m *MediaType) ValidateAll() error {
	return m.validate(true)
}

func (m *MediaType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSchema()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MediaTypeValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MediaTypeValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSchema()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MediaTypeValidationError{
				field:  "Schema",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExample()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MediaTypeValidationError{
					field:  "Example",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MediaTypeValidationError{
					field:  "Example",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExample()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MediaTypeValidationError{
				field:  "Example",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExamples()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MediaTypeValidationError{
					field:  "Examples",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MediaTypeValidationError{
					field:  "Examples",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExamples()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MediaTypeValidationError{
				field:  "Examples",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEncoding()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MediaTypeValidationError{
					field:  "Encoding",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MediaTypeValidationError{
					field:  "Encoding",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEncoding()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MediaTypeValidationError{
				field:  "Encoding",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MediaTypeValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MediaTypeValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MediaTypeValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MediaTypeMultiError(errors)
	}

	return nil
}

// MediaTypeMultiError is an error wrapping multiple validation errors returned
// by MediaType.ValidateAll() if the designated constraints aren't met.
type MediaTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MediaTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MediaTypeMultiError) AllErrors() []error { return m }

// MediaTypeValidationError is the validation error returned by
// MediaType.Validate if the designated constraints aren't met.
type MediaTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MediaTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MediaTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MediaTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MediaTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MediaTypeValidationError) ErrorName() string { return "MediaTypeValidationError" }

// Error satisfies the builtin error interface
func (e MediaTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMediaType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MediaTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MediaTypeValidationError{}

// Validate checks the field values on MediaTypes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MediaTypes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MediaTypes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MediaTypesMultiError, or
// nil if none found.
func (m *MediaTypes) ValidateAll() error {
	return m.validate(true)
}

func (m *MediaTypes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAdditionalProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MediaTypesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MediaTypesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MediaTypesValidationError{
					field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MediaTypesMultiError(errors)
	}

	return nil
}

// MediaTypesMultiError is an error wrapping multiple validation errors
// returned by MediaTypes.ValidateAll() if the designated constraints aren't met.
type MediaTypesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MediaTypesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MediaTypesMultiError) AllErrors() []error { return m }

// MediaTypesValidationError is the validation error returned by
// MediaTypes.Validate if the designated constraints aren't met.
type MediaTypesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MediaTypesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MediaTypesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MediaTypesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MediaTypesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MediaTypesValidationError) ErrorName() string { return "MediaTypesValidationError" }

// Error satisfies the builtin error interface
func (e MediaTypesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMediaTypes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MediaTypesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MediaTypesValidationError{}

// Validate checks the field values on NamedAny with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NamedAny) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamedAny with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NamedAnyMultiError, or nil
// if none found.
func (m *NamedAny) ValidateAll() error {
	return m.validate(true)
}

func (m *NamedAny) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamedAnyValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamedAnyValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamedAnyValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NamedAnyMultiError(errors)
	}

	return nil
}

// NamedAnyMultiError is an error wrapping multiple validation errors returned
// by NamedAny.ValidateAll() if the designated constraints aren't met.
type NamedAnyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamedAnyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamedAnyMultiError) AllErrors() []error { return m }

// NamedAnyValidationError is the validation error returned by
// NamedAny.Validate if the designated constraints aren't met.
type NamedAnyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamedAnyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamedAnyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamedAnyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamedAnyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamedAnyValidationError) ErrorName() string { return "NamedAnyValidationError" }

// Error satisfies the builtin error interface
func (e NamedAnyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamedAny.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamedAnyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamedAnyValidationError{}

// Validate checks the field values on NamedCallbackOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NamedCallbackOrReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamedCallbackOrReference with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NamedCallbackOrReferenceMultiError, or nil if none found.
func (m *NamedCallbackOrReference) ValidateAll() error {
	return m.validate(true)
}

func (m *NamedCallbackOrReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamedCallbackOrReferenceValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamedCallbackOrReferenceValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamedCallbackOrReferenceValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NamedCallbackOrReferenceMultiError(errors)
	}

	return nil
}

// NamedCallbackOrReferenceMultiError is an error wrapping multiple validation
// errors returned by NamedCallbackOrReference.ValidateAll() if the designated
// constraints aren't met.
type NamedCallbackOrReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamedCallbackOrReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamedCallbackOrReferenceMultiError) AllErrors() []error { return m }

// NamedCallbackOrReferenceValidationError is the validation error returned by
// NamedCallbackOrReference.Validate if the designated constraints aren't met.
type NamedCallbackOrReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamedCallbackOrReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamedCallbackOrReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamedCallbackOrReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamedCallbackOrReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamedCallbackOrReferenceValidationError) ErrorName() string {
	return "NamedCallbackOrReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e NamedCallbackOrReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamedCallbackOrReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamedCallbackOrReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamedCallbackOrReferenceValidationError{}

// Validate checks the field values on NamedEncoding with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NamedEncoding) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamedEncoding with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NamedEncodingMultiError, or
// nil if none found.
func (m *NamedEncoding) ValidateAll() error {
	return m.validate(true)
}

func (m *NamedEncoding) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamedEncodingValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamedEncodingValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamedEncodingValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NamedEncodingMultiError(errors)
	}

	return nil
}

// NamedEncodingMultiError is an error wrapping multiple validation errors
// returned by NamedEncoding.ValidateAll() if the designated constraints
// aren't met.
type NamedEncodingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamedEncodingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamedEncodingMultiError) AllErrors() []error { return m }

// NamedEncodingValidationError is the validation error returned by
// NamedEncoding.Validate if the designated constraints aren't met.
type NamedEncodingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamedEncodingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamedEncodingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamedEncodingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamedEncodingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamedEncodingValidationError) ErrorName() string { return "NamedEncodingValidationError" }

// Error satisfies the builtin error interface
func (e NamedEncodingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamedEncoding.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamedEncodingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamedEncodingValidationError{}

// Validate checks the field values on NamedExampleOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NamedExampleOrReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamedExampleOrReference with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NamedExampleOrReferenceMultiError, or nil if none found.
func (m *NamedExampleOrReference) ValidateAll() error {
	return m.validate(true)
}

func (m *NamedExampleOrReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamedExampleOrReferenceValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamedExampleOrReferenceValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamedExampleOrReferenceValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NamedExampleOrReferenceMultiError(errors)
	}

	return nil
}

// NamedExampleOrReferenceMultiError is an error wrapping multiple validation
// errors returned by NamedExampleOrReference.ValidateAll() if the designated
// constraints aren't met.
type NamedExampleOrReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamedExampleOrReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamedExampleOrReferenceMultiError) AllErrors() []error { return m }

// NamedExampleOrReferenceValidationError is the validation error returned by
// NamedExampleOrReference.Validate if the designated constraints aren't met.
type NamedExampleOrReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamedExampleOrReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamedExampleOrReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamedExampleOrReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamedExampleOrReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamedExampleOrReferenceValidationError) ErrorName() string {
	return "NamedExampleOrReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e NamedExampleOrReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamedExampleOrReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamedExampleOrReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamedExampleOrReferenceValidationError{}

// Validate checks the field values on NamedHeaderOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NamedHeaderOrReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamedHeaderOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NamedHeaderOrReferenceMultiError, or nil if none found.
func (m *NamedHeaderOrReference) ValidateAll() error {
	return m.validate(true)
}

func (m *NamedHeaderOrReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamedHeaderOrReferenceValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamedHeaderOrReferenceValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamedHeaderOrReferenceValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NamedHeaderOrReferenceMultiError(errors)
	}

	return nil
}

// NamedHeaderOrReferenceMultiError is an error wrapping multiple validation
// errors returned by NamedHeaderOrReference.ValidateAll() if the designated
// constraints aren't met.
type NamedHeaderOrReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamedHeaderOrReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamedHeaderOrReferenceMultiError) AllErrors() []error { return m }

// NamedHeaderOrReferenceValidationError is the validation error returned by
// NamedHeaderOrReference.Validate if the designated constraints aren't met.
type NamedHeaderOrReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamedHeaderOrReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamedHeaderOrReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamedHeaderOrReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamedHeaderOrReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamedHeaderOrReferenceValidationError) ErrorName() string {
	return "NamedHeaderOrReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e NamedHeaderOrReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamedHeaderOrReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamedHeaderOrReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamedHeaderOrReferenceValidationError{}

// Validate checks the field values on NamedLinkOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NamedLinkOrReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamedLinkOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NamedLinkOrReferenceMultiError, or nil if none found.
func (m *NamedLinkOrReference) ValidateAll() error {
	return m.validate(true)
}

func (m *NamedLinkOrReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamedLinkOrReferenceValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamedLinkOrReferenceValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamedLinkOrReferenceValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NamedLinkOrReferenceMultiError(errors)
	}

	return nil
}

// NamedLinkOrReferenceMultiError is an error wrapping multiple validation
// errors returned by NamedLinkOrReference.ValidateAll() if the designated
// constraints aren't met.
type NamedLinkOrReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamedLinkOrReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamedLinkOrReferenceMultiError) AllErrors() []error { return m }

// NamedLinkOrReferenceValidationError is the validation error returned by
// NamedLinkOrReference.Validate if the designated constraints aren't met.
type NamedLinkOrReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamedLinkOrReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamedLinkOrReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamedLinkOrReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamedLinkOrReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamedLinkOrReferenceValidationError) ErrorName() string {
	return "NamedLinkOrReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e NamedLinkOrReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamedLinkOrReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamedLinkOrReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamedLinkOrReferenceValidationError{}

// Validate checks the field values on NamedMediaType with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NamedMediaType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamedMediaType with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NamedMediaTypeMultiError,
// or nil if none found.
func (m *NamedMediaType) ValidateAll() error {
	return m.validate(true)
}

func (m *NamedMediaType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamedMediaTypeValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamedMediaTypeValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamedMediaTypeValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NamedMediaTypeMultiError(errors)
	}

	return nil
}

// NamedMediaTypeMultiError is an error wrapping multiple validation errors
// returned by NamedMediaType.ValidateAll() if the designated constraints
// aren't met.
type NamedMediaTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamedMediaTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamedMediaTypeMultiError) AllErrors() []error { return m }

// NamedMediaTypeValidationError is the validation error returned by
// NamedMediaType.Validate if the designated constraints aren't met.
type NamedMediaTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamedMediaTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamedMediaTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamedMediaTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamedMediaTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamedMediaTypeValidationError) ErrorName() string { return "NamedMediaTypeValidationError" }

// Error satisfies the builtin error interface
func (e NamedMediaTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamedMediaType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamedMediaTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamedMediaTypeValidationError{}

// Validate checks the field values on NamedParameterOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NamedParameterOrReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamedParameterOrReference with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NamedParameterOrReferenceMultiError, or nil if none found.
func (m *NamedParameterOrReference) ValidateAll() error {
	return m.validate(true)
}

func (m *NamedParameterOrReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamedParameterOrReferenceValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamedParameterOrReferenceValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamedParameterOrReferenceValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NamedParameterOrReferenceMultiError(errors)
	}

	return nil
}

// NamedParameterOrReferenceMultiError is an error wrapping multiple validation
// errors returned by NamedParameterOrReference.ValidateAll() if the
// designated constraints aren't met.
type NamedParameterOrReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamedParameterOrReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamedParameterOrReferenceMultiError) AllErrors() []error { return m }

// NamedParameterOrReferenceValidationError is the validation error returned by
// NamedParameterOrReference.Validate if the designated constraints aren't met.
type NamedParameterOrReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamedParameterOrReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamedParameterOrReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamedParameterOrReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamedParameterOrReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamedParameterOrReferenceValidationError) ErrorName() string {
	return "NamedParameterOrReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e NamedParameterOrReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamedParameterOrReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamedParameterOrReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamedParameterOrReferenceValidationError{}

// Validate checks the field values on NamedPathItem with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NamedPathItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamedPathItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NamedPathItemMultiError, or
// nil if none found.
func (m *NamedPathItem) ValidateAll() error {
	return m.validate(true)
}

func (m *NamedPathItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamedPathItemValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamedPathItemValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamedPathItemValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NamedPathItemMultiError(errors)
	}

	return nil
}

// NamedPathItemMultiError is an error wrapping multiple validation errors
// returned by NamedPathItem.ValidateAll() if the designated constraints
// aren't met.
type NamedPathItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamedPathItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamedPathItemMultiError) AllErrors() []error { return m }

// NamedPathItemValidationError is the validation error returned by
// NamedPathItem.Validate if the designated constraints aren't met.
type NamedPathItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamedPathItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamedPathItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamedPathItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamedPathItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamedPathItemValidationError) ErrorName() string { return "NamedPathItemValidationError" }

// Error satisfies the builtin error interface
func (e NamedPathItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamedPathItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamedPathItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamedPathItemValidationError{}

// Validate checks the field values on NamedRequestBodyOrReference with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NamedRequestBodyOrReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamedRequestBodyOrReference with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NamedRequestBodyOrReferenceMultiError, or nil if none found.
func (m *NamedRequestBodyOrReference) ValidateAll() error {
	return m.validate(true)
}

func (m *NamedRequestBodyOrReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamedRequestBodyOrReferenceValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamedRequestBodyOrReferenceValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamedRequestBodyOrReferenceValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NamedRequestBodyOrReferenceMultiError(errors)
	}

	return nil
}

// NamedRequestBodyOrReferenceMultiError is an error wrapping multiple
// validation errors returned by NamedRequestBodyOrReference.ValidateAll() if
// the designated constraints aren't met.
type NamedRequestBodyOrReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamedRequestBodyOrReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamedRequestBodyOrReferenceMultiError) AllErrors() []error { return m }

// NamedRequestBodyOrReferenceValidationError is the validation error returned
// by NamedRequestBodyOrReference.Validate if the designated constraints
// aren't met.
type NamedRequestBodyOrReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamedRequestBodyOrReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamedRequestBodyOrReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamedRequestBodyOrReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamedRequestBodyOrReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamedRequestBodyOrReferenceValidationError) ErrorName() string {
	return "NamedRequestBodyOrReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e NamedRequestBodyOrReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamedRequestBodyOrReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamedRequestBodyOrReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamedRequestBodyOrReferenceValidationError{}

// Validate checks the field values on NamedResponseOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NamedResponseOrReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamedResponseOrReference with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NamedResponseOrReferenceMultiError, or nil if none found.
func (m *NamedResponseOrReference) ValidateAll() error {
	return m.validate(true)
}

func (m *NamedResponseOrReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamedResponseOrReferenceValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamedResponseOrReferenceValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamedResponseOrReferenceValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NamedResponseOrReferenceMultiError(errors)
	}

	return nil
}

// NamedResponseOrReferenceMultiError is an error wrapping multiple validation
// errors returned by NamedResponseOrReference.ValidateAll() if the designated
// constraints aren't met.
type NamedResponseOrReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamedResponseOrReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamedResponseOrReferenceMultiError) AllErrors() []error { return m }

// NamedResponseOrReferenceValidationError is the validation error returned by
// NamedResponseOrReference.Validate if the designated constraints aren't met.
type NamedResponseOrReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamedResponseOrReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamedResponseOrReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamedResponseOrReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamedResponseOrReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamedResponseOrReferenceValidationError) ErrorName() string {
	return "NamedResponseOrReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e NamedResponseOrReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamedResponseOrReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamedResponseOrReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamedResponseOrReferenceValidationError{}

// Validate checks the field values on NamedSchemaOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NamedSchemaOrReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamedSchemaOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NamedSchemaOrReferenceMultiError, or nil if none found.
func (m *NamedSchemaOrReference) ValidateAll() error {
	return m.validate(true)
}

func (m *NamedSchemaOrReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamedSchemaOrReferenceValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamedSchemaOrReferenceValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamedSchemaOrReferenceValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NamedSchemaOrReferenceMultiError(errors)
	}

	return nil
}

// NamedSchemaOrReferenceMultiError is an error wrapping multiple validation
// errors returned by NamedSchemaOrReference.ValidateAll() if the designated
// constraints aren't met.
type NamedSchemaOrReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamedSchemaOrReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamedSchemaOrReferenceMultiError) AllErrors() []error { return m }

// NamedSchemaOrReferenceValidationError is the validation error returned by
// NamedSchemaOrReference.Validate if the designated constraints aren't met.
type NamedSchemaOrReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamedSchemaOrReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamedSchemaOrReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamedSchemaOrReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamedSchemaOrReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamedSchemaOrReferenceValidationError) ErrorName() string {
	return "NamedSchemaOrReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e NamedSchemaOrReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamedSchemaOrReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamedSchemaOrReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamedSchemaOrReferenceValidationError{}

// Validate checks the field values on NamedSecuritySchemeOrReference with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NamedSecuritySchemeOrReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamedSecuritySchemeOrReference with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// NamedSecuritySchemeOrReferenceMultiError, or nil if none found.
func (m *NamedSecuritySchemeOrReference) ValidateAll() error {
	return m.validate(true)
}

func (m *NamedSecuritySchemeOrReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamedSecuritySchemeOrReferenceValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamedSecuritySchemeOrReferenceValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamedSecuritySchemeOrReferenceValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NamedSecuritySchemeOrReferenceMultiError(errors)
	}

	return nil
}

// NamedSecuritySchemeOrReferenceMultiError is an error wrapping multiple
// validation errors returned by NamedSecuritySchemeOrReference.ValidateAll()
// if the designated constraints aren't met.
type NamedSecuritySchemeOrReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamedSecuritySchemeOrReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamedSecuritySchemeOrReferenceMultiError) AllErrors() []error { return m }

// NamedSecuritySchemeOrReferenceValidationError is the validation error
// returned by NamedSecuritySchemeOrReference.Validate if the designated
// constraints aren't met.
type NamedSecuritySchemeOrReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamedSecuritySchemeOrReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamedSecuritySchemeOrReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamedSecuritySchemeOrReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamedSecuritySchemeOrReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamedSecuritySchemeOrReferenceValidationError) ErrorName() string {
	return "NamedSecuritySchemeOrReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e NamedSecuritySchemeOrReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamedSecuritySchemeOrReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamedSecuritySchemeOrReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamedSecuritySchemeOrReferenceValidationError{}

// Validate checks the field values on NamedServerVariable with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NamedServerVariable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamedServerVariable with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NamedServerVariableMultiError, or nil if none found.
func (m *NamedServerVariable) ValidateAll() error {
	return m.validate(true)
}

func (m *NamedServerVariable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamedServerVariableValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamedServerVariableValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamedServerVariableValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NamedServerVariableMultiError(errors)
	}

	return nil
}

// NamedServerVariableMultiError is an error wrapping multiple validation
// errors returned by NamedServerVariable.ValidateAll() if the designated
// constraints aren't met.
type NamedServerVariableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamedServerVariableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamedServerVariableMultiError) AllErrors() []error { return m }

// NamedServerVariableValidationError is the validation error returned by
// NamedServerVariable.Validate if the designated constraints aren't met.
type NamedServerVariableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamedServerVariableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamedServerVariableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamedServerVariableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamedServerVariableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamedServerVariableValidationError) ErrorName() string {
	return "NamedServerVariableValidationError"
}

// Error satisfies the builtin error interface
func (e NamedServerVariableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamedServerVariable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamedServerVariableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamedServerVariableValidationError{}

// Validate checks the field values on NamedString with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NamedString) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamedString with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NamedStringMultiError, or
// nil if none found.
func (m *NamedString) ValidateAll() error {
	return m.validate(true)
}

func (m *NamedString) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Value

	if len(errors) > 0 {
		return NamedStringMultiError(errors)
	}

	return nil
}

// NamedStringMultiError is an error wrapping multiple validation errors
// returned by NamedString.ValidateAll() if the designated constraints aren't met.
type NamedStringMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamedStringMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamedStringMultiError) AllErrors() []error { return m }

// NamedStringValidationError is the validation error returned by
// NamedString.Validate if the designated constraints aren't met.
type NamedStringValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamedStringValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamedStringValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamedStringValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamedStringValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamedStringValidationError) ErrorName() string { return "NamedStringValidationError" }

// Error satisfies the builtin error interface
func (e NamedStringValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamedString.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamedStringValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamedStringValidationError{}

// Validate checks the field values on NamedStringArray with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NamedStringArray) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamedStringArray with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NamedStringArrayMultiError, or nil if none found.
func (m *NamedStringArray) ValidateAll() error {
	return m.validate(true)
}

func (m *NamedStringArray) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamedStringArrayValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamedStringArrayValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamedStringArrayValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NamedStringArrayMultiError(errors)
	}

	return nil
}

// NamedStringArrayMultiError is an error wrapping multiple validation errors
// returned by NamedStringArray.ValidateAll() if the designated constraints
// aren't met.
type NamedStringArrayMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamedStringArrayMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamedStringArrayMultiError) AllErrors() []error { return m }

// NamedStringArrayValidationError is the validation error returned by
// NamedStringArray.Validate if the designated constraints aren't met.
type NamedStringArrayValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamedStringArrayValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamedStringArrayValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamedStringArrayValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamedStringArrayValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamedStringArrayValidationError) ErrorName() string { return "NamedStringArrayValidationError" }

// Error satisfies the builtin error interface
func (e NamedStringArrayValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamedStringArray.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamedStringArrayValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamedStringArrayValidationError{}

// Validate checks the field values on OauthFlow with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OauthFlow) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OauthFlow with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OauthFlowMultiError, or nil
// if none found.
func (m *OauthFlow) ValidateAll() error {
	return m.validate(true)
}

func (m *OauthFlow) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AuthorizationUrl

	// no validation rules for TokenUrl

	// no validation rules for RefreshUrl

	if all {
		switch v := interface{}(m.GetScopes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OauthFlowValidationError{
					field:  "Scopes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OauthFlowValidationError{
					field:  "Scopes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScopes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OauthFlowValidationError{
				field:  "Scopes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OauthFlowValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OauthFlowValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OauthFlowValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OauthFlowMultiError(errors)
	}

	return nil
}

// OauthFlowMultiError is an error wrapping multiple validation errors returned
// by OauthFlow.ValidateAll() if the designated constraints aren't met.
type OauthFlowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OauthFlowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OauthFlowMultiError) AllErrors() []error { return m }

// OauthFlowValidationError is the validation error returned by
// OauthFlow.Validate if the designated constraints aren't met.
type OauthFlowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OauthFlowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OauthFlowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OauthFlowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OauthFlowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OauthFlowValidationError) ErrorName() string { return "OauthFlowValidationError" }

// Error satisfies the builtin error interface
func (e OauthFlowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOauthFlow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OauthFlowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OauthFlowValidationError{}

// Validate checks the field values on OauthFlows with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OauthFlows) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OauthFlows with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OauthFlowsMultiError, or
// nil if none found.
func (m *OauthFlows) ValidateAll() error {
	return m.validate(true)
}

func (m *OauthFlows) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetImplicit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OauthFlowsValidationError{
					field:  "Implicit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OauthFlowsValidationError{
					field:  "Implicit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetImplicit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OauthFlowsValidationError{
				field:  "Implicit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPassword()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OauthFlowsValidationError{
					field:  "Password",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OauthFlowsValidationError{
					field:  "Password",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPassword()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OauthFlowsValidationError{
				field:  "Password",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClientCredentials()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OauthFlowsValidationError{
					field:  "ClientCredentials",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OauthFlowsValidationError{
					field:  "ClientCredentials",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClientCredentials()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OauthFlowsValidationError{
				field:  "ClientCredentials",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAuthorizationCode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OauthFlowsValidationError{
					field:  "AuthorizationCode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OauthFlowsValidationError{
					field:  "AuthorizationCode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthorizationCode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OauthFlowsValidationError{
				field:  "AuthorizationCode",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OauthFlowsValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OauthFlowsValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OauthFlowsValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OauthFlowsMultiError(errors)
	}

	return nil
}

// OauthFlowsMultiError is an error wrapping multiple validation errors
// returned by OauthFlows.ValidateAll() if the designated constraints aren't met.
type OauthFlowsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OauthFlowsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OauthFlowsMultiError) AllErrors() []error { return m }

// OauthFlowsValidationError is the validation error returned by
// OauthFlows.Validate if the designated constraints aren't met.
type OauthFlowsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OauthFlowsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OauthFlowsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OauthFlowsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OauthFlowsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OauthFlowsValidationError) ErrorName() string { return "OauthFlowsValidationError" }

// Error satisfies the builtin error interface
func (e OauthFlowsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOauthFlows.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OauthFlowsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OauthFlowsValidationError{}

// Validate checks the field values on Object with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Object) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Object with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ObjectMultiError, or nil if none found.
func (m *Object) ValidateAll() error {
	return m.validate(true)
}

func (m *Object) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAdditionalProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectValidationError{
					field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ObjectMultiError(errors)
	}

	return nil
}

// ObjectMultiError is an error wrapping multiple validation errors returned by
// Object.ValidateAll() if the designated constraints aren't met.
type ObjectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ObjectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ObjectMultiError) AllErrors() []error { return m }

// ObjectValidationError is the validation error returned by Object.Validate if
// the designated constraints aren't met.
type ObjectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ObjectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ObjectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ObjectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ObjectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ObjectValidationError) ErrorName() string { return "ObjectValidationError" }

// Error satisfies the builtin error interface
func (e ObjectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sObject.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ObjectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ObjectValidationError{}

// Validate checks the field values on Operation with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Operation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Operation with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OperationMultiError, or nil
// if none found.
func (m *Operation) ValidateAll() error {
	return m.validate(true)
}

func (m *Operation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Summary

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetExternalDocs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationValidationError{
					field:  "ExternalDocs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationValidationError{
					field:  "ExternalDocs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExternalDocs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationValidationError{
				field:  "ExternalDocs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OperationId

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRequestBody()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationValidationError{
					field:  "RequestBody",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationValidationError{
					field:  "RequestBody",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequestBody()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationValidationError{
				field:  "RequestBody",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResponses()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationValidationError{
					field:  "Responses",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationValidationError{
					field:  "Responses",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponses()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationValidationError{
				field:  "Responses",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCallbacks()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationValidationError{
					field:  "Callbacks",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationValidationError{
					field:  "Callbacks",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCallbacks()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationValidationError{
				field:  "Callbacks",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Deprecated

	for idx, item := range m.GetSecurity() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationValidationError{
						field:  fmt.Sprintf("Security[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationValidationError{
						field:  fmt.Sprintf("Security[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationValidationError{
					field:  fmt.Sprintf("Security[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetServers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationValidationError{
						field:  fmt.Sprintf("Servers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationValidationError{
						field:  fmt.Sprintf("Servers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationValidationError{
					field:  fmt.Sprintf("Servers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OperationMultiError(errors)
	}

	return nil
}

// OperationMultiError is an error wrapping multiple validation errors returned
// by Operation.ValidateAll() if the designated constraints aren't met.
type OperationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationMultiError) AllErrors() []error { return m }

// OperationValidationError is the validation error returned by
// Operation.Validate if the designated constraints aren't met.
type OperationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationValidationError) ErrorName() string { return "OperationValidationError" }

// Error satisfies the builtin error interface
func (e OperationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationValidationError{}

// Validate checks the field values on Parameter with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Parameter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Parameter with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ParameterMultiError, or nil
// if none found.
func (m *Parameter) ValidateAll() error {
	return m.validate(true)
}

func (m *Parameter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for In

	// no validation rules for Description

	// no validation rules for Required

	// no validation rules for Deprecated

	// no validation rules for AllowEmptyValue

	// no validation rules for Style

	// no validation rules for Explode

	// no validation rules for AllowReserved

	if all {
		switch v := interface{}(m.GetSchema()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSchema()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterValidationError{
				field:  "Schema",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExample()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterValidationError{
					field:  "Example",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterValidationError{
					field:  "Example",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExample()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterValidationError{
				field:  "Example",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExamples()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterValidationError{
					field:  "Examples",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterValidationError{
					field:  "Examples",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExamples()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterValidationError{
				field:  "Examples",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetContent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterValidationError{
				field:  "Content",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ParameterMultiError(errors)
	}

	return nil
}

// ParameterMultiError is an error wrapping multiple validation errors returned
// by Parameter.ValidateAll() if the designated constraints aren't met.
type ParameterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterMultiError) AllErrors() []error { return m }

// ParameterValidationError is the validation error returned by
// Parameter.Validate if the designated constraints aren't met.
type ParameterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterValidationError) ErrorName() string { return "ParameterValidationError" }

// Error satisfies the builtin error interface
func (e ParameterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterValidationError{}

// Validate checks the field values on ParameterOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParameterOrReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParameterOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParameterOrReferenceMultiError, or nil if none found.
func (m *ParameterOrReference) ValidateAll() error {
	return m.validate(true)
}

func (m *ParameterOrReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Oneof.(type) {
	case *ParameterOrReference_Parameter:
		if v == nil {
			err := ParameterOrReferenceValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetParameter()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterOrReferenceValidationError{
						field:  "Parameter",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterOrReferenceValidationError{
						field:  "Parameter",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetParameter()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterOrReferenceValidationError{
					field:  "Parameter",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ParameterOrReference_Reference:
		if v == nil {
			err := ParameterOrReferenceValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReference()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParameterOrReferenceValidationError{
						field:  "Reference",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParameterOrReferenceValidationError{
						field:  "Reference",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReference()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParameterOrReferenceValidationError{
					field:  "Reference",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ParameterOrReferenceMultiError(errors)
	}

	return nil
}

// ParameterOrReferenceMultiError is an error wrapping multiple validation
// errors returned by ParameterOrReference.ValidateAll() if the designated
// constraints aren't met.
type ParameterOrReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterOrReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterOrReferenceMultiError) AllErrors() []error { return m }

// ParameterOrReferenceValidationError is the validation error returned by
// ParameterOrReference.Validate if the designated constraints aren't met.
type ParameterOrReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterOrReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterOrReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterOrReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterOrReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterOrReferenceValidationError) ErrorName() string {
	return "ParameterOrReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e ParameterOrReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameterOrReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterOrReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterOrReferenceValidationError{}

// Validate checks the field values on ParametersOrReferences with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParametersOrReferences) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParametersOrReferences with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParametersOrReferencesMultiError, or nil if none found.
func (m *ParametersOrReferences) ValidateAll() error {
	return m.validate(true)
}

func (m *ParametersOrReferences) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAdditionalProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParametersOrReferencesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParametersOrReferencesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParametersOrReferencesValidationError{
					field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ParametersOrReferencesMultiError(errors)
	}

	return nil
}

// ParametersOrReferencesMultiError is an error wrapping multiple validation
// errors returned by ParametersOrReferences.ValidateAll() if the designated
// constraints aren't met.
type ParametersOrReferencesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParametersOrReferencesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParametersOrReferencesMultiError) AllErrors() []error { return m }

// ParametersOrReferencesValidationError is the validation error returned by
// ParametersOrReferences.Validate if the designated constraints aren't met.
type ParametersOrReferencesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParametersOrReferencesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParametersOrReferencesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParametersOrReferencesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParametersOrReferencesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParametersOrReferencesValidationError) ErrorName() string {
	return "ParametersOrReferencesValidationError"
}

// Error satisfies the builtin error interface
func (e ParametersOrReferencesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParametersOrReferences.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParametersOrReferencesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParametersOrReferencesValidationError{}

// Validate checks the field values on PathItem with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PathItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PathItem with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PathItemMultiError, or nil
// if none found.
func (m *PathItem) ValidateAll() error {
	return m.validate(true)
}

func (m *PathItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for XRef

	// no validation rules for Summary

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetGet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PathItemValidationError{
					field:  "Get",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PathItemValidationError{
					field:  "Get",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PathItemValidationError{
				field:  "Get",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPut()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PathItemValidationError{
					field:  "Put",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PathItemValidationError{
					field:  "Put",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPut()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PathItemValidationError{
				field:  "Put",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPost()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PathItemValidationError{
					field:  "Post",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PathItemValidationError{
					field:  "Post",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPost()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PathItemValidationError{
				field:  "Post",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDelete()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PathItemValidationError{
					field:  "Delete",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PathItemValidationError{
					field:  "Delete",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDelete()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PathItemValidationError{
				field:  "Delete",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PathItemValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PathItemValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PathItemValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetHead()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PathItemValidationError{
					field:  "Head",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PathItemValidationError{
					field:  "Head",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHead()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PathItemValidationError{
				field:  "Head",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPatch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PathItemValidationError{
					field:  "Patch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PathItemValidationError{
					field:  "Patch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPatch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PathItemValidationError{
				field:  "Patch",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTrace()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PathItemValidationError{
					field:  "Trace",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PathItemValidationError{
					field:  "Trace",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTrace()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PathItemValidationError{
				field:  "Trace",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetServers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PathItemValidationError{
						field:  fmt.Sprintf("Servers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PathItemValidationError{
						field:  fmt.Sprintf("Servers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PathItemValidationError{
					field:  fmt.Sprintf("Servers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PathItemValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PathItemValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PathItemValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PathItemValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PathItemValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PathItemValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PathItemMultiError(errors)
	}

	return nil
}

// PathItemMultiError is an error wrapping multiple validation errors returned
// by PathItem.ValidateAll() if the designated constraints aren't met.
type PathItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PathItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PathItemMultiError) AllErrors() []error { return m }

// PathItemValidationError is the validation error returned by
// PathItem.Validate if the designated constraints aren't met.
type PathItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PathItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PathItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PathItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PathItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PathItemValidationError) ErrorName() string { return "PathItemValidationError" }

// Error satisfies the builtin error interface
func (e PathItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPathItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PathItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PathItemValidationError{}

// Validate checks the field values on Paths with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Paths) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Paths with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PathsMultiError, or nil if none found.
func (m *Paths) ValidateAll() error {
	return m.validate(true)
}

func (m *Paths) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPath() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PathsValidationError{
						field:  fmt.Sprintf("Path[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PathsValidationError{
						field:  fmt.Sprintf("Path[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PathsValidationError{
					field:  fmt.Sprintf("Path[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PathsValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PathsValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PathsValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PathsMultiError(errors)
	}

	return nil
}

// PathsMultiError is an error wrapping multiple validation errors returned by
// Paths.ValidateAll() if the designated constraints aren't met.
type PathsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PathsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PathsMultiError) AllErrors() []error { return m }

// PathsValidationError is the validation error returned by Paths.Validate if
// the designated constraints aren't met.
type PathsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PathsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PathsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PathsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PathsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PathsValidationError) ErrorName() string { return "PathsValidationError" }

// Error satisfies the builtin error interface
func (e PathsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaths.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PathsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PathsValidationError{}

// Validate checks the field values on Properties with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Properties) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Properties with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PropertiesMultiError, or
// nil if none found.
func (m *Properties) ValidateAll() error {
	return m.validate(true)
}

func (m *Properties) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAdditionalProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PropertiesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PropertiesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PropertiesValidationError{
					field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PropertiesMultiError(errors)
	}

	return nil
}

// PropertiesMultiError is an error wrapping multiple validation errors
// returned by Properties.ValidateAll() if the designated constraints aren't met.
type PropertiesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PropertiesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PropertiesMultiError) AllErrors() []error { return m }

// PropertiesValidationError is the validation error returned by
// Properties.Validate if the designated constraints aren't met.
type PropertiesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PropertiesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PropertiesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PropertiesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PropertiesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PropertiesValidationError) ErrorName() string { return "PropertiesValidationError" }

// Error satisfies the builtin error interface
func (e PropertiesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProperties.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PropertiesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PropertiesValidationError{}

// Validate checks the field values on Reference with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Reference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Reference with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReferenceMultiError, or nil
// if none found.
func (m *Reference) ValidateAll() error {
	return m.validate(true)
}

func (m *Reference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for XRef

	// no validation rules for Summary

	// no validation rules for Description

	if len(errors) > 0 {
		return ReferenceMultiError(errors)
	}

	return nil
}

// ReferenceMultiError is an error wrapping multiple validation errors returned
// by Reference.ValidateAll() if the designated constraints aren't met.
type ReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceMultiError) AllErrors() []error { return m }

// ReferenceValidationError is the validation error returned by
// Reference.Validate if the designated constraints aren't met.
type ReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceValidationError) ErrorName() string { return "ReferenceValidationError" }

// Error satisfies the builtin error interface
func (e ReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceValidationError{}

// Validate checks the field values on RequestBodiesOrReferences with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RequestBodiesOrReferences) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RequestBodiesOrReferences with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RequestBodiesOrReferencesMultiError, or nil if none found.
func (m *RequestBodiesOrReferences) ValidateAll() error {
	return m.validate(true)
}

func (m *RequestBodiesOrReferences) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAdditionalProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestBodiesOrReferencesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestBodiesOrReferencesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestBodiesOrReferencesValidationError{
					field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RequestBodiesOrReferencesMultiError(errors)
	}

	return nil
}

// RequestBodiesOrReferencesMultiError is an error wrapping multiple validation
// errors returned by RequestBodiesOrReferences.ValidateAll() if the
// designated constraints aren't met.
type RequestBodiesOrReferencesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestBodiesOrReferencesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestBodiesOrReferencesMultiError) AllErrors() []error { return m }

// RequestBodiesOrReferencesValidationError is the validation error returned by
// RequestBodiesOrReferences.Validate if the designated constraints aren't met.
type RequestBodiesOrReferencesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestBodiesOrReferencesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestBodiesOrReferencesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestBodiesOrReferencesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestBodiesOrReferencesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestBodiesOrReferencesValidationError) ErrorName() string {
	return "RequestBodiesOrReferencesValidationError"
}

// Error satisfies the builtin error interface
func (e RequestBodiesOrReferencesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestBodiesOrReferences.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestBodiesOrReferencesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestBodiesOrReferencesValidationError{}

// Validate checks the field values on RequestBody with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RequestBody) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RequestBody with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RequestBodyMultiError, or
// nil if none found.
func (m *RequestBody) ValidateAll() error {
	return m.validate(true)
}

func (m *RequestBody) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetContent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RequestBodyValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RequestBodyValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RequestBodyValidationError{
				field:  "Content",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Required

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestBodyValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestBodyValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestBodyValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RequestBodyMultiError(errors)
	}

	return nil
}

// RequestBodyMultiError is an error wrapping multiple validation errors
// returned by RequestBody.ValidateAll() if the designated constraints aren't met.
type RequestBodyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestBodyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestBodyMultiError) AllErrors() []error { return m }

// RequestBodyValidationError is the validation error returned by
// RequestBody.Validate if the designated constraints aren't met.
type RequestBodyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestBodyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestBodyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestBodyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestBodyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestBodyValidationError) ErrorName() string { return "RequestBodyValidationError" }

// Error satisfies the builtin error interface
func (e RequestBodyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestBody.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestBodyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestBodyValidationError{}

// Validate checks the field values on RequestBodyOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RequestBodyOrReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RequestBodyOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RequestBodyOrReferenceMultiError, or nil if none found.
func (m *RequestBodyOrReference) ValidateAll() error {
	return m.validate(true)
}

func (m *RequestBodyOrReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Oneof.(type) {
	case *RequestBodyOrReference_RequestBody:
		if v == nil {
			err := RequestBodyOrReferenceValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRequestBody()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestBodyOrReferenceValidationError{
						field:  "RequestBody",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestBodyOrReferenceValidationError{
						field:  "RequestBody",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequestBody()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestBodyOrReferenceValidationError{
					field:  "RequestBody",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RequestBodyOrReference_Reference:
		if v == nil {
			err := RequestBodyOrReferenceValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReference()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestBodyOrReferenceValidationError{
						field:  "Reference",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestBodyOrReferenceValidationError{
						field:  "Reference",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReference()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestBodyOrReferenceValidationError{
					field:  "Reference",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return RequestBodyOrReferenceMultiError(errors)
	}

	return nil
}

// RequestBodyOrReferenceMultiError is an error wrapping multiple validation
// errors returned by RequestBodyOrReference.ValidateAll() if the designated
// constraints aren't met.
type RequestBodyOrReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestBodyOrReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestBodyOrReferenceMultiError) AllErrors() []error { return m }

// RequestBodyOrReferenceValidationError is the validation error returned by
// RequestBodyOrReference.Validate if the designated constraints aren't met.
type RequestBodyOrReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestBodyOrReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestBodyOrReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestBodyOrReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestBodyOrReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestBodyOrReferenceValidationError) ErrorName() string {
	return "RequestBodyOrReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e RequestBodyOrReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestBodyOrReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestBodyOrReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestBodyOrReferenceValidationError{}

// Validate checks the field values on Response with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Response with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResponseMultiError, or nil
// if none found.
func (m *Response) ValidateAll() error {
	return m.validate(true)
}

func (m *Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetHeaders()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResponseValidationError{
					field:  "Headers",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResponseValidationError{
					field:  "Headers",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHeaders()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResponseValidationError{
				field:  "Headers",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetContent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResponseValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResponseValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResponseValidationError{
				field:  "Content",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLinks()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResponseValidationError{
					field:  "Links",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResponseValidationError{
					field:  "Links",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLinks()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResponseValidationError{
				field:  "Links",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ResponseMultiError(errors)
	}

	return nil
}

// ResponseMultiError is an error wrapping multiple validation errors returned
// by Response.ValidateAll() if the designated constraints aren't met.
type ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResponseMultiError) AllErrors() []error { return m }

// ResponseValidationError is the validation error returned by
// Response.Validate if the designated constraints aren't met.
type ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResponseValidationError) ErrorName() string { return "ResponseValidationError" }

// Error satisfies the builtin error interface
func (e ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResponseValidationError{}

// Validate checks the field values on ResponseOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResponseOrReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResponseOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResponseOrReferenceMultiError, or nil if none found.
func (m *ResponseOrReference) ValidateAll() error {
	return m.validate(true)
}

func (m *ResponseOrReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Oneof.(type) {
	case *ResponseOrReference_Response:
		if v == nil {
			err := ResponseOrReferenceValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseOrReferenceValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseOrReferenceValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseOrReferenceValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ResponseOrReference_Reference:
		if v == nil {
			err := ResponseOrReferenceValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReference()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponseOrReferenceValidationError{
						field:  "Reference",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponseOrReferenceValidationError{
						field:  "Reference",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReference()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponseOrReferenceValidationError{
					field:  "Reference",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ResponseOrReferenceMultiError(errors)
	}

	return nil
}

// ResponseOrReferenceMultiError is an error wrapping multiple validation
// errors returned by ResponseOrReference.ValidateAll() if the designated
// constraints aren't met.
type ResponseOrReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResponseOrReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResponseOrReferenceMultiError) AllErrors() []error { return m }

// ResponseOrReferenceValidationError is the validation error returned by
// ResponseOrReference.Validate if the designated constraints aren't met.
type ResponseOrReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResponseOrReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResponseOrReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResponseOrReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResponseOrReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResponseOrReferenceValidationError) ErrorName() string {
	return "ResponseOrReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e ResponseOrReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResponseOrReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResponseOrReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResponseOrReferenceValidationError{}

// Validate checks the field values on Responses with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Responses) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Responses with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResponsesMultiError, or nil
// if none found.
func (m *Responses) ValidateAll() error {
	return m.validate(true)
}

func (m *Responses) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDefault()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResponsesValidationError{
					field:  "Default",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResponsesValidationError{
					field:  "Default",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefault()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResponsesValidationError{
				field:  "Default",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetResponseOrReference() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponsesValidationError{
						field:  fmt.Sprintf("ResponseOrReference[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponsesValidationError{
						field:  fmt.Sprintf("ResponseOrReference[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponsesValidationError{
					field:  fmt.Sprintf("ResponseOrReference[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponsesValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponsesValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponsesValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ResponsesMultiError(errors)
	}

	return nil
}

// ResponsesMultiError is an error wrapping multiple validation errors returned
// by Responses.ValidateAll() if the designated constraints aren't met.
type ResponsesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResponsesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResponsesMultiError) AllErrors() []error { return m }

// ResponsesValidationError is the validation error returned by
// Responses.Validate if the designated constraints aren't met.
type ResponsesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResponsesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResponsesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResponsesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResponsesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResponsesValidationError) ErrorName() string { return "ResponsesValidationError" }

// Error satisfies the builtin error interface
func (e ResponsesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResponses.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResponsesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResponsesValidationError{}

// Validate checks the field values on ResponsesOrReferences with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResponsesOrReferences) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResponsesOrReferences with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResponsesOrReferencesMultiError, or nil if none found.
func (m *ResponsesOrReferences) ValidateAll() error {
	return m.validate(true)
}

func (m *ResponsesOrReferences) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAdditionalProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResponsesOrReferencesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResponsesOrReferencesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResponsesOrReferencesValidationError{
					field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ResponsesOrReferencesMultiError(errors)
	}

	return nil
}

// ResponsesOrReferencesMultiError is an error wrapping multiple validation
// errors returned by ResponsesOrReferences.ValidateAll() if the designated
// constraints aren't met.
type ResponsesOrReferencesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResponsesOrReferencesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResponsesOrReferencesMultiError) AllErrors() []error { return m }

// ResponsesOrReferencesValidationError is the validation error returned by
// ResponsesOrReferences.Validate if the designated constraints aren't met.
type ResponsesOrReferencesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResponsesOrReferencesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResponsesOrReferencesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResponsesOrReferencesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResponsesOrReferencesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResponsesOrReferencesValidationError) ErrorName() string {
	return "ResponsesOrReferencesValidationError"
}

// Error satisfies the builtin error interface
func (e ResponsesOrReferencesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResponsesOrReferences.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResponsesOrReferencesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResponsesOrReferencesValidationError{}

// Validate checks the field values on Schema with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Schema) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Schema with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SchemaMultiError, or nil if none found.
func (m *Schema) ValidateAll() error {
	return m.validate(true)
}

func (m *Schema) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Nullable

	if all {
		switch v := interface{}(m.GetDiscriminator()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SchemaValidationError{
					field:  "Discriminator",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SchemaValidationError{
					field:  "Discriminator",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDiscriminator()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SchemaValidationError{
				field:  "Discriminator",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ReadOnly

	// no validation rules for WriteOnly

	if all {
		switch v := interface{}(m.GetXml()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SchemaValidationError{
					field:  "Xml",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SchemaValidationError{
					field:  "Xml",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetXml()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SchemaValidationError{
				field:  "Xml",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExternalDocs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SchemaValidationError{
					field:  "ExternalDocs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SchemaValidationError{
					field:  "ExternalDocs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExternalDocs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SchemaValidationError{
				field:  "ExternalDocs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExample()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SchemaValidationError{
					field:  "Example",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SchemaValidationError{
					field:  "Example",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExample()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SchemaValidationError{
				field:  "Example",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Deprecated

	// no validation rules for Title

	// no validation rules for MultipleOf

	// no validation rules for Maximum

	// no validation rules for ExclusiveMaximum

	// no validation rules for Minimum

	// no validation rules for ExclusiveMinimum

	// no validation rules for MaxLength

	// no validation rules for MinLength

	// no validation rules for Pattern

	// no validation rules for MaxItems

	// no validation rules for MinItems

	// no validation rules for UniqueItems

	// no validation rules for MaxProperties

	// no validation rules for MinProperties

	for idx, item := range m.GetEnum() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SchemaValidationError{
						field:  fmt.Sprintf("Enum[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SchemaValidationError{
						field:  fmt.Sprintf("Enum[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SchemaValidationError{
					field:  fmt.Sprintf("Enum[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Type

	for idx, item := range m.GetAllOf() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SchemaValidationError{
						field:  fmt.Sprintf("AllOf[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SchemaValidationError{
						field:  fmt.Sprintf("AllOf[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SchemaValidationError{
					field:  fmt.Sprintf("AllOf[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOneOf() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SchemaValidationError{
						field:  fmt.Sprintf("OneOf[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SchemaValidationError{
						field:  fmt.Sprintf("OneOf[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SchemaValidationError{
					field:  fmt.Sprintf("OneOf[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAnyOf() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SchemaValidationError{
						field:  fmt.Sprintf("AnyOf[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SchemaValidationError{
						field:  fmt.Sprintf("AnyOf[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SchemaValidationError{
					field:  fmt.Sprintf("AnyOf[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetNot()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SchemaValidationError{
					field:  "Not",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SchemaValidationError{
					field:  "Not",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNot()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SchemaValidationError{
				field:  "Not",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetItems()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SchemaValidationError{
					field:  "Items",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SchemaValidationError{
					field:  "Items",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItems()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SchemaValidationError{
				field:  "Items",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SchemaValidationError{
					field:  "Properties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SchemaValidationError{
					field:  "Properties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SchemaValidationError{
				field:  "Properties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAdditionalProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SchemaValidationError{
					field:  "AdditionalProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SchemaValidationError{
					field:  "AdditionalProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAdditionalProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SchemaValidationError{
				field:  "AdditionalProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDefault()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SchemaValidationError{
					field:  "Default",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SchemaValidationError{
					field:  "Default",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefault()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SchemaValidationError{
				field:  "Default",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Description

	// no validation rules for Format

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SchemaValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SchemaValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SchemaValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SchemaMultiError(errors)
	}

	return nil
}

// SchemaMultiError is an error wrapping multiple validation errors returned by
// Schema.ValidateAll() if the designated constraints aren't met.
type SchemaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SchemaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SchemaMultiError) AllErrors() []error { return m }

// SchemaValidationError is the validation error returned by Schema.Validate if
// the designated constraints aren't met.
type SchemaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SchemaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SchemaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SchemaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SchemaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SchemaValidationError) ErrorName() string { return "SchemaValidationError" }

// Error satisfies the builtin error interface
func (e SchemaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSchema.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SchemaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SchemaValidationError{}

// Validate checks the field values on SchemaOrReference with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SchemaOrReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SchemaOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SchemaOrReferenceMultiError, or nil if none found.
func (m *SchemaOrReference) ValidateAll() error {
	return m.validate(true)
}

func (m *SchemaOrReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Oneof.(type) {
	case *SchemaOrReference_Schema:
		if v == nil {
			err := SchemaOrReferenceValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSchema()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SchemaOrReferenceValidationError{
						field:  "Schema",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SchemaOrReferenceValidationError{
						field:  "Schema",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSchema()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SchemaOrReferenceValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SchemaOrReference_Reference:
		if v == nil {
			err := SchemaOrReferenceValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReference()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SchemaOrReferenceValidationError{
						field:  "Reference",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SchemaOrReferenceValidationError{
						field:  "Reference",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReference()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SchemaOrReferenceValidationError{
					field:  "Reference",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SchemaOrReferenceMultiError(errors)
	}

	return nil
}

// SchemaOrReferenceMultiError is an error wrapping multiple validation errors
// returned by SchemaOrReference.ValidateAll() if the designated constraints
// aren't met.
type SchemaOrReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SchemaOrReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SchemaOrReferenceMultiError) AllErrors() []error { return m }

// SchemaOrReferenceValidationError is the validation error returned by
// SchemaOrReference.Validate if the designated constraints aren't met.
type SchemaOrReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SchemaOrReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SchemaOrReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SchemaOrReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SchemaOrReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SchemaOrReferenceValidationError) ErrorName() string {
	return "SchemaOrReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e SchemaOrReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSchemaOrReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SchemaOrReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SchemaOrReferenceValidationError{}

// Validate checks the field values on SchemasOrReferences with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SchemasOrReferences) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SchemasOrReferences with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SchemasOrReferencesMultiError, or nil if none found.
func (m *SchemasOrReferences) ValidateAll() error {
	return m.validate(true)
}

func (m *SchemasOrReferences) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAdditionalProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SchemasOrReferencesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SchemasOrReferencesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SchemasOrReferencesValidationError{
					field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SchemasOrReferencesMultiError(errors)
	}

	return nil
}

// SchemasOrReferencesMultiError is an error wrapping multiple validation
// errors returned by SchemasOrReferences.ValidateAll() if the designated
// constraints aren't met.
type SchemasOrReferencesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SchemasOrReferencesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SchemasOrReferencesMultiError) AllErrors() []error { return m }

// SchemasOrReferencesValidationError is the validation error returned by
// SchemasOrReferences.Validate if the designated constraints aren't met.
type SchemasOrReferencesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SchemasOrReferencesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SchemasOrReferencesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SchemasOrReferencesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SchemasOrReferencesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SchemasOrReferencesValidationError) ErrorName() string {
	return "SchemasOrReferencesValidationError"
}

// Error satisfies the builtin error interface
func (e SchemasOrReferencesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSchemasOrReferences.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SchemasOrReferencesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SchemasOrReferencesValidationError{}

// Validate checks the field values on SecurityRequirement with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SecurityRequirement) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecurityRequirement with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SecurityRequirementMultiError, or nil if none found.
func (m *SecurityRequirement) ValidateAll() error {
	return m.validate(true)
}

func (m *SecurityRequirement) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAdditionalProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SecurityRequirementValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SecurityRequirementValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SecurityRequirementValidationError{
					field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SecurityRequirementMultiError(errors)
	}

	return nil
}

// SecurityRequirementMultiError is an error wrapping multiple validation
// errors returned by SecurityRequirement.ValidateAll() if the designated
// constraints aren't met.
type SecurityRequirementMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecurityRequirementMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecurityRequirementMultiError) AllErrors() []error { return m }

// SecurityRequirementValidationError is the validation error returned by
// SecurityRequirement.Validate if the designated constraints aren't met.
type SecurityRequirementValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecurityRequirementValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecurityRequirementValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecurityRequirementValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecurityRequirementValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecurityRequirementValidationError) ErrorName() string {
	return "SecurityRequirementValidationError"
}

// Error satisfies the builtin error interface
func (e SecurityRequirementValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecurityRequirement.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecurityRequirementValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecurityRequirementValidationError{}

// Validate checks the field values on SecurityScheme with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SecurityScheme) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecurityScheme with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SecuritySchemeMultiError,
// or nil if none found.
func (m *SecurityScheme) ValidateAll() error {
	return m.validate(true)
}

func (m *SecurityScheme) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Description

	// no validation rules for Name

	// no validation rules for In

	// no validation rules for Scheme

	// no validation rules for BearerFormat

	if all {
		switch v := interface{}(m.GetFlows()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SecuritySchemeValidationError{
					field:  "Flows",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SecuritySchemeValidationError{
					field:  "Flows",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFlows()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SecuritySchemeValidationError{
				field:  "Flows",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OpenIdConnectUrl

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SecuritySchemeValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SecuritySchemeValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SecuritySchemeValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SecuritySchemeMultiError(errors)
	}

	return nil
}

// SecuritySchemeMultiError is an error wrapping multiple validation errors
// returned by SecurityScheme.ValidateAll() if the designated constraints
// aren't met.
type SecuritySchemeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecuritySchemeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecuritySchemeMultiError) AllErrors() []error { return m }

// SecuritySchemeValidationError is the validation error returned by
// SecurityScheme.Validate if the designated constraints aren't met.
type SecuritySchemeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecuritySchemeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecuritySchemeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecuritySchemeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecuritySchemeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecuritySchemeValidationError) ErrorName() string { return "SecuritySchemeValidationError" }

// Error satisfies the builtin error interface
func (e SecuritySchemeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecurityScheme.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecuritySchemeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecuritySchemeValidationError{}

// Validate checks the field values on SecuritySchemeOrReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SecuritySchemeOrReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecuritySchemeOrReference with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SecuritySchemeOrReferenceMultiError, or nil if none found.
func (m *SecuritySchemeOrReference) ValidateAll() error {
	return m.validate(true)
}

func (m *SecuritySchemeOrReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Oneof.(type) {
	case *SecuritySchemeOrReference_SecurityScheme:
		if v == nil {
			err := SecuritySchemeOrReferenceValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSecurityScheme()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SecuritySchemeOrReferenceValidationError{
						field:  "SecurityScheme",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SecuritySchemeOrReferenceValidationError{
						field:  "SecurityScheme",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSecurityScheme()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SecuritySchemeOrReferenceValidationError{
					field:  "SecurityScheme",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SecuritySchemeOrReference_Reference:
		if v == nil {
			err := SecuritySchemeOrReferenceValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReference()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SecuritySchemeOrReferenceValidationError{
						field:  "Reference",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SecuritySchemeOrReferenceValidationError{
						field:  "Reference",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReference()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SecuritySchemeOrReferenceValidationError{
					field:  "Reference",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SecuritySchemeOrReferenceMultiError(errors)
	}

	return nil
}

// SecuritySchemeOrReferenceMultiError is an error wrapping multiple validation
// errors returned by SecuritySchemeOrReference.ValidateAll() if the
// designated constraints aren't met.
type SecuritySchemeOrReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecuritySchemeOrReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecuritySchemeOrReferenceMultiError) AllErrors() []error { return m }

// SecuritySchemeOrReferenceValidationError is the validation error returned by
// SecuritySchemeOrReference.Validate if the designated constraints aren't met.
type SecuritySchemeOrReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecuritySchemeOrReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecuritySchemeOrReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecuritySchemeOrReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecuritySchemeOrReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecuritySchemeOrReferenceValidationError) ErrorName() string {
	return "SecuritySchemeOrReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e SecuritySchemeOrReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecuritySchemeOrReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecuritySchemeOrReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecuritySchemeOrReferenceValidationError{}

// Validate checks the field values on SecuritySchemesOrReferences with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SecuritySchemesOrReferences) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecuritySchemesOrReferences with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SecuritySchemesOrReferencesMultiError, or nil if none found.
func (m *SecuritySchemesOrReferences) ValidateAll() error {
	return m.validate(true)
}

func (m *SecuritySchemesOrReferences) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAdditionalProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SecuritySchemesOrReferencesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SecuritySchemesOrReferencesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SecuritySchemesOrReferencesValidationError{
					field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SecuritySchemesOrReferencesMultiError(errors)
	}

	return nil
}

// SecuritySchemesOrReferencesMultiError is an error wrapping multiple
// validation errors returned by SecuritySchemesOrReferences.ValidateAll() if
// the designated constraints aren't met.
type SecuritySchemesOrReferencesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecuritySchemesOrReferencesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecuritySchemesOrReferencesMultiError) AllErrors() []error { return m }

// SecuritySchemesOrReferencesValidationError is the validation error returned
// by SecuritySchemesOrReferences.Validate if the designated constraints
// aren't met.
type SecuritySchemesOrReferencesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecuritySchemesOrReferencesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecuritySchemesOrReferencesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecuritySchemesOrReferencesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecuritySchemesOrReferencesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecuritySchemesOrReferencesValidationError) ErrorName() string {
	return "SecuritySchemesOrReferencesValidationError"
}

// Error satisfies the builtin error interface
func (e SecuritySchemesOrReferencesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecuritySchemesOrReferences.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecuritySchemesOrReferencesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecuritySchemesOrReferencesValidationError{}

// Validate checks the field values on Server with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Server) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Server with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ServerMultiError, or nil if none found.
func (m *Server) ValidateAll() error {
	return m.validate(true)
}

func (m *Server) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetVariables()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServerValidationError{
					field:  "Variables",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServerValidationError{
					field:  "Variables",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVariables()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServerValidationError{
				field:  "Variables",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ServerMultiError(errors)
	}

	return nil
}

// ServerMultiError is an error wrapping multiple validation errors returned by
// Server.ValidateAll() if the designated constraints aren't met.
type ServerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerMultiError) AllErrors() []error { return m }

// ServerValidationError is the validation error returned by Server.Validate if
// the designated constraints aren't met.
type ServerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerValidationError) ErrorName() string { return "ServerValidationError" }

// Error satisfies the builtin error interface
func (e ServerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerValidationError{}

// Validate checks the field values on ServerVariable with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ServerVariable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServerVariable with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ServerVariableMultiError,
// or nil if none found.
func (m *ServerVariable) ValidateAll() error {
	return m.validate(true)
}

func (m *ServerVariable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Default

	// no validation rules for Description

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerVariableValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerVariableValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerVariableValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ServerVariableMultiError(errors)
	}

	return nil
}

// ServerVariableMultiError is an error wrapping multiple validation errors
// returned by ServerVariable.ValidateAll() if the designated constraints
// aren't met.
type ServerVariableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerVariableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerVariableMultiError) AllErrors() []error { return m }

// ServerVariableValidationError is the validation error returned by
// ServerVariable.Validate if the designated constraints aren't met.
type ServerVariableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerVariableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerVariableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerVariableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerVariableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerVariableValidationError) ErrorName() string { return "ServerVariableValidationError" }

// Error satisfies the builtin error interface
func (e ServerVariableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServerVariable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerVariableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerVariableValidationError{}

// Validate checks the field values on ServerVariables with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ServerVariables) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServerVariables with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServerVariablesMultiError, or nil if none found.
func (m *ServerVariables) ValidateAll() error {
	return m.validate(true)
}

func (m *ServerVariables) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAdditionalProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerVariablesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerVariablesValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerVariablesValidationError{
					field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ServerVariablesMultiError(errors)
	}

	return nil
}

// ServerVariablesMultiError is an error wrapping multiple validation errors
// returned by ServerVariables.ValidateAll() if the designated constraints
// aren't met.
type ServerVariablesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerVariablesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerVariablesMultiError) AllErrors() []error { return m }

// ServerVariablesValidationError is the validation error returned by
// ServerVariables.Validate if the designated constraints aren't met.
type ServerVariablesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerVariablesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerVariablesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerVariablesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerVariablesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerVariablesValidationError) ErrorName() string { return "ServerVariablesValidationError" }

// Error satisfies the builtin error interface
func (e ServerVariablesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServerVariables.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerVariablesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerVariablesValidationError{}

// Validate checks the field values on SpecificationExtension with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SpecificationExtension) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpecificationExtension with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SpecificationExtensionMultiError, or nil if none found.
func (m *SpecificationExtension) ValidateAll() error {
	return m.validate(true)
}

func (m *SpecificationExtension) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Oneof.(type) {
	case *SpecificationExtension_Number:
		if v == nil {
			err := SpecificationExtensionValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Number
	case *SpecificationExtension_Boolean:
		if v == nil {
			err := SpecificationExtensionValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Boolean
	case *SpecificationExtension_String_:
		if v == nil {
			err := SpecificationExtensionValidationError{
				field:  "Oneof",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for String_
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SpecificationExtensionMultiError(errors)
	}

	return nil
}

// SpecificationExtensionMultiError is an error wrapping multiple validation
// errors returned by SpecificationExtension.ValidateAll() if the designated
// constraints aren't met.
type SpecificationExtensionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpecificationExtensionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpecificationExtensionMultiError) AllErrors() []error { return m }

// SpecificationExtensionValidationError is the validation error returned by
// SpecificationExtension.Validate if the designated constraints aren't met.
type SpecificationExtensionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpecificationExtensionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpecificationExtensionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpecificationExtensionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpecificationExtensionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpecificationExtensionValidationError) ErrorName() string {
	return "SpecificationExtensionValidationError"
}

// Error satisfies the builtin error interface
func (e SpecificationExtensionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecificationExtension.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpecificationExtensionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpecificationExtensionValidationError{}

// Validate checks the field values on StringArray with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StringArray) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StringArray with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StringArrayMultiError, or
// nil if none found.
func (m *StringArray) ValidateAll() error {
	return m.validate(true)
}

func (m *StringArray) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return StringArrayMultiError(errors)
	}

	return nil
}

// StringArrayMultiError is an error wrapping multiple validation errors
// returned by StringArray.ValidateAll() if the designated constraints aren't met.
type StringArrayMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StringArrayMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StringArrayMultiError) AllErrors() []error { return m }

// StringArrayValidationError is the validation error returned by
// StringArray.Validate if the designated constraints aren't met.
type StringArrayValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringArrayValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringArrayValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringArrayValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringArrayValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringArrayValidationError) ErrorName() string { return "StringArrayValidationError" }

// Error satisfies the builtin error interface
func (e StringArrayValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringArray.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringArrayValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringArrayValidationError{}

// Validate checks the field values on Strings with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Strings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Strings with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StringsMultiError, or nil if none found.
func (m *Strings) ValidateAll() error {
	return m.validate(true)
}

func (m *Strings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAdditionalProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StringsValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StringsValidationError{
						field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StringsValidationError{
					field:  fmt.Sprintf("AdditionalProperties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return StringsMultiError(errors)
	}

	return nil
}

// StringsMultiError is an error wrapping multiple validation errors returned
// by Strings.ValidateAll() if the designated constraints aren't met.
type StringsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StringsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StringsMultiError) AllErrors() []error { return m }

// StringsValidationError is the validation error returned by Strings.Validate
// if the designated constraints aren't met.
type StringsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringsValidationError) ErrorName() string { return "StringsValidationError" }

// Error satisfies the builtin error interface
func (e StringsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStrings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringsValidationError{}

// Validate checks the field values on Tag with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Tag) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Tag with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TagMultiError, or nil if none found.
func (m *Tag) ValidateAll() error {
	return m.validate(true)
}

func (m *Tag) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetExternalDocs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TagValidationError{
					field:  "ExternalDocs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TagValidationError{
					field:  "ExternalDocs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExternalDocs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TagValidationError{
				field:  "ExternalDocs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TagValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TagValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TagValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TagMultiError(errors)
	}

	return nil
}

// TagMultiError is an error wrapping multiple validation errors returned by
// Tag.ValidateAll() if the designated constraints aren't met.
type TagMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TagMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TagMultiError) AllErrors() []error { return m }

// TagValidationError is the validation error returned by Tag.Validate if the
// designated constraints aren't met.
type TagValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TagValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TagValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TagValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TagValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TagValidationError) ErrorName() string { return "TagValidationError" }

// Error satisfies the builtin error interface
func (e TagValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTag.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TagValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TagValidationError{}

// Validate checks the field values on Xml with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Xml) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Xml with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in XmlMultiError, or nil if none found.
func (m *Xml) ValidateAll() error {
	return m.validate(true)
}

func (m *Xml) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Namespace

	// no validation rules for Prefix

	// no validation rules for Attribute

	// no validation rules for Wrapped

	for idx, item := range m.GetSpecificationExtension() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, XmlValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, XmlValidationError{
						field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return XmlValidationError{
					field:  fmt.Sprintf("SpecificationExtension[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return XmlMultiError(errors)
	}

	return nil
}

// XmlMultiError is an error wrapping multiple validation errors returned by
// Xml.ValidateAll() if the designated constraints aren't met.
type XmlMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m XmlMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m XmlMultiError) AllErrors() []error { return m }

// XmlValidationError is the validation error returned by Xml.Validate if the
// designated constraints aren't met.
type XmlValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e XmlValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e XmlValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e XmlValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e XmlValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e XmlValidationError) ErrorName() string { return "XmlValidationError" }

// Error satisfies the builtin error interface
func (e XmlValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sXml.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = XmlValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = XmlValidationError{}
